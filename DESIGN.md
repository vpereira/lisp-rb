# Design Decisions

This document outlines the design decisions made while creating a Lisp-like language interpreter in Ruby.

## Tokenization

The tokenization process is designed to be simple and straightforward. The code reads the input string and separates it into individual tokens based on spaces and parentheses. This allows for easy parsing of the input string, with minimal overhead. The tokenization process does not consider any syntax errors at this stage, as these will be identified during the parsing phase.

## Parsing

The parser is designed to be recursive, allowing for nested expressions to be handled easily. It processes the tokens generated during the tokenization phase and constructs an Abstract Syntax Tree (AST) based on the Lisp-like language syntax. At this stage, any syntax errors will be identified and raised, ensuring the code is valid before it is evaluated.

## Evaluation

The evaluation process is built around the idea of an environment that contains a mapping of symbols to their corresponding values or functions. This allows for easy handling of variables and functions within the Lisp-like language. The environment is implemented as a simple Ruby hash that can be extended with new symbols and functions as needed.

During evaluation, the interpreter traverses the AST generated by the parser and evaluates each expression based on its type. This includes handling variables, functions, and control structures such as `if`, `loop`, and `repeat`.

## Extensibility

This is achieved by using a global environment that can be updated with new symbols and functions as needed. This allows users to add new functionality to the language without needing to modify the core interpreter code.

## Error Handling

TBD

## Read-Eval-Print Loop (REPL)

The REPL is designed to handle incomplete expressions, allowing users to enter multi-line expressions without issues.
